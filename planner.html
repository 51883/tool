<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Smart Credit Planner</title>
  <style>
    :root {
      --primary: #2563eb;
      --primary-hover: #1d4ed8;
      --bg-body: #f3f4f6;
      --bg-card: #ffffff;
      --text-main: #111827;
      --text-sec: #6b7280;
      --border: #e5e7eb;
      --danger: #ef4444;
      --success: #10b981;
      --warning: #f59e0b;
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --radius: 12px;
      --font-sans: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "PingFang SC", "Microsoft YaHei", sans-serif;
    }

    * { box-sizing: border-box; outline: none; }
    
    body {
      margin: 0;
      font-family: var(--font-sans);
      background: var(--bg-body);
      color: var(--text-main);
      line-height: 1.5;
      padding-bottom: 40px;
    }

    /* Layout & Typography */
    .container { max-width: 1200px; margin: 0 auto; padding: 0 20px; }
    
    header {
      background: var(--bg-card);
      border-bottom: 1px solid var(--border);
      padding: 20px 0;
      margin-bottom: 32px;
      box-shadow: var(--shadow-sm);
    }
    
    h1 { margin: 0; font-size: 20px; font-weight: 700; color: var(--text-main); display: flex; align-items: center; gap: 8px; }
    h2 { font-size: 16px; font-weight: 600; margin: 0 0 16px; display: flex; align-items: center; justify-content: space-between; }
    
    .subtitle { color: var(--text-sec); font-size: 14px; font-weight: 400; margin-top: 4px; }

    /* Cards & Panels */
    .card {
      background: var(--bg-card);
      border-radius: var(--radius);
      box-shadow: var(--shadow-md);
      border: 1px solid var(--border);
      padding: 24px;
      margin-bottom: 24px;
      transition: all 0.2s;
    }

    /* Inputs & Forms */
    .form-group { margin-bottom: 0; }
    label { display: block; font-size: 12px; font-weight: 600; color: var(--text-sec); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; }
    
    input, select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 14px;
      color: var(--text-main);
      background: #f9fafb;
      transition: all 0.15s;
    }
    input:focus, select:focus {
      background: #fff;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }
    
    /* Buttons */
    .btn {
      display: inline-flex; align-items: center; justify-content: center;
      padding: 8px 16px; border-radius: 8px; font-size: 13px; font-weight: 500;
      cursor: pointer; border: 1px solid transparent; transition: all 0.15s; gap: 6px;
    }
    .btn-primary { background: var(--text-main); color: #fff; }
    .btn-primary:hover { background: #000; }
    
    .btn-sec { background: #fff; border-color: var(--border); color: var(--text-main); }
    .btn-sec:hover { background: #f9fafb; border-color: #d1d5db; }
    
    .btn-ghost { background: transparent; color: var(--text-sec); padding: 4px 8px; }
    .btn-ghost:hover { color: var(--text-main); background: #f3f4f6; }
    
    .btn-danger-ghost { background: transparent; color: var(--text-sec); padding: 6px; }
    .btn-danger-ghost:hover { color: var(--danger); background: #fef2f2; }

    /* Grid Layouts */
    .grid-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
    @media (max-width: 900px) { .grid-2 { grid-template-columns: 1fr; } }

    /* Data Table */
    .data-table-wrapper {
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }
    table { width: 100%; border-collapse: collapse; }
    th {
      background: #f9fafb; text-align: left; padding: 12px 16px;
      font-size: 12px; color: var(--text-sec); font-weight: 600;
      border-bottom: 1px solid var(--border); white-space: nowrap;
    }
    td {
      padding: 12px 16px; border-bottom: 1px solid var(--border);
      font-size: 14px; color: var(--text-main); vertical-align: middle;
    }
    tr:last-child td { border-bottom: none; }
    tr:hover td { background: #f9fafb; }
    
    .table-input { 
      border: 1px solid transparent; background: transparent; padding: 6px 8px; margin: -6px -8px; width: 100%; 
    }
    .table-input:hover, .table-input:focus {
      background: #fff; border-color: var(--border);
    }
    
    /* Stats & Pills */
    .stat-box {
      background: #f8fafc; border-radius: 8px; padding: 16px;
      border: 1px solid var(--border); text-align: center;
    }
    .stat-label { font-size: 12px; color: var(--text-sec); margin-bottom: 4px; }
    .stat-value { font-size: 20px; font-weight: 700; color: var(--primary); }
    
    .pill { display: inline-flex; align-items: center; padding: 2px 8px; border-radius: 99px; font-size: 12px; font-weight: 500; }
    .pill.blue { background: #eff6ff; color: #2563eb; }
    .pill.green { background: #ecfdf5; color: #059669; }
    .pill.red { background: #fef2f2; color: #dc2626; }
    .pill.warning { background: #fffbeb; color: #b45309; }
    .pill.purple { background: #f3e8ff; color: #7c3aed; }

    /* Timeline Styling */
    .timeline-item {
      display: flex; gap: 16px; padding: 16px 0; border-bottom: 1px dashed var(--border);
      align-items: flex-start;
    }
    .timeline-item:last-child { border-bottom: none; }
    .timeline-item.done { opacity: 0.42; }
    .timeline-item.done .t-amount { text-decoration: line-through; }
    .done-toggle { cursor: pointer; user-select: none; }
    .done-toggle:hover { opacity: 0.9; }
    
    .t-date {
      width: 70px; flex-shrink: 0; text-align: center;
      background: #f3f4f6; border-radius: 6px; padding: 8px 4px;
      display: flex; flex-direction: column; justify-content: center;
    }
    .t-day { font-size: 18px; font-weight: 700; line-height: 1; color: var(--text-main); }
    .t-month { font-size: 11px; color: var(--text-sec); margin-top: 2px; }
    
    .t-content { flex: 1; }
    .t-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
    .t-card-name { font-weight: 600; font-size: 14px; }
    .t-amount { font-weight: 700; font-size: 15px; color: var(--text-main); font-family: monospace; }
    
    .t-meta { display: flex; gap: 10px; font-size: 12px; color: var(--text-sec); align-items: center; }
    .icon { width: 14px; height: 14px; fill: currentColor; opacity: 0.7; }

    /* Utility */
    .flex-center { display: flex; align-items: center; justify-content: center; }
    .text-right { text-align: right; }
    .w-full { width: 100%; }
    .mt-4 { margin-top: 16px; }
    .text-sm { font-size: 12px; }
    .muted { color: var(--text-sec); }
  </style>
</head>

<body>

<header>
  <div class="container">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div>
        <h1>ğŸ’³ Smart Planner <span style="font-size:12px; background:#e0e7ff; color:#3730a3; padding:2px 8px; border-radius:99px;">Pro</span></h1>
        <div class="subtitle">ä¿¡ç”¨å¡èµ„é‡‘å ç”¨æœ€å¤§åŒ–è®¡ç®—å™¨ï¼ˆè‡ªåŠ¨è§„åˆ’ï¼‰</div>
      </div>
      <div id="globalStat" style="text-align:right;">
        <!-- JS Populated -->
      </div>
    </div>
  </div>
</header>

<div class="container">

  <!-- 1. å…¨å±€é…ç½® -->
  <div class="card">
    <h2>âš™ï¸ å…¨å±€è®¾ç½®</h2>
    <div class="grid-controls">
      <div>
        <label>è§„åˆ’æœˆä»½</label>
        <input id="planMonth" type="month" />
      </div>
      <div>
        <label>å•ç¬”åˆ·å¡èŒƒå›´ (å…ƒ)</label>
        <div style="display:flex; gap:8px; align-items:center;">
          <input id="minChunk" type="number" value="10000" min="10000" step="1000" placeholder="Min" />
          <span class="muted">-</span>
          <input id="maxChunk" type="number" value="50000" min="10000" step="1000" placeholder="Max" />
        </div>
      </div>
      <div>
        <label>å•†æˆ·æ•°é‡ï¼ˆæ¯æœˆï¼‰</label>
        <input id="merchantCount" type="number" value="5" min="1" step="1" />
      </div>
      <div>
        <label>å•å•†æˆ·æœˆæ”¶æ¬¾ä¸Šé™ (å…ƒ)</label>
        <input id="merchantCap" type="number" value="50000" min="10000" step="1000" />
      </div>
      <div style="display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap;">
        <div class="w-full">
          <label>è®¡åˆ’é”å®š</label>
          <div class="muted" style="font-size:12px;">åˆ·æ–°é¡µé¢ä¸ä¼šå˜ï¼›éœ€è¦æ¢ä¸€ç‰ˆæ—¶ç‚¹â€œé‡æ–°ç”Ÿæˆâ€ã€‚</div>
        </div>
        <button id="regenPlan" class="btn btn-sec">é‡æ–°ç”Ÿæˆ</button>
        <button id="resetLocal" class="btn btn-ghost">æ¸…é™¤æœ¬åœ°</button>
      </div>
      <div>
        <label>è®¡ç®—æ¨¡å¼</label>
        <select id="mode">
          <option value="steady" selected>ç¨³å®šå¾ªç¯ (æœ€å¤§åŒ–å ç”¨)</option>
          <option value="oneoff">å•æ¬¡æ‰§è¡Œ (æ–°å¡/é¦–æœˆ)</option>
        </select>
      </div>
    </div>
  </div>

  <!-- 2. å¡ç‰‡ç®¡ç† -->
  <div class="card" style="padding:0; overflow:hidden;">
    <div style="padding: 20px 24px; border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center;">
      <div>
        <h2 style="margin:0;">ğŸ’³ å¡ç‰‡ç®¡ç†</h2>
        <div class="subtitle">å®æ—¶ä¿®æ”¹å‚æ•°ï¼Œç»“æœå³åˆ»åˆ·æ–°</div>
      </div>
      <button id="addCard" class="btn btn-sec">+ æ·»åŠ æ–°å¡</button>
    </div>
    
    <div style="overflow-x: auto;">
      <table id="cardsTable">
        <thead>
          <tr>
            <th style="width:200px;">å¡ç‰‡åç§°</th>
            <th style="width:140px;">é¢åº¦ (å…ƒ)</th>
            <th style="width:100px;">è´¦å•æ—¥</th>
            <th style="width:100px;">è¿˜æ¬¾æ—¥</th>
            <th style="width:140px;">æœ¬æœˆç›®æ ‡ (å…ƒ)</th>
            <th style="width:100px; text-align:right;">æ“ä½œ</th>
          </tr>
        </thead>
        <tbody id="cardsTbody">
          <!-- JS Rows -->
        </tbody>
      </table>
    </div>
    <div class="muted" style="padding:12px 24px; font-size:12px; background:#f9fafb; border-top:1px solid var(--border);">
      æç¤ºï¼šè‹¥è¿˜æ¬¾æ—¥å°äºè´¦å•æ—¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è¯†åˆ«ä¸ºæ¬¡æœˆè¿˜æ¬¾ã€‚
    </div>
  </div>

  <div class="grid-2">
    <!-- 3. æ—¶é—´è½´ -->
    <div class="card">
      <h2>ğŸ“… æ™ºèƒ½æ‰§è¡Œæ—¶é—´è½´ <span class="pill blue" id="eventCount">0 ç¬”</span> <span class="pill blue" id="remainSum">å‰©ä½™ Â¥0</span></h2>
      <div id="timeline" style="max-height: 600px; overflow-y:auto; padding-right:4px;">
        <!-- Timeline JS -->
      </div>
    </div>

    <!-- 4. è¯¦ç»†åˆ†æ -->
    <div class="card">
      <h2>ğŸ“Š èµ„é‡‘å ç”¨åˆ†æ</h2>
      <div id="summary" style="display:flex; flex-direction:column; gap:16px;">
        <!-- Summary JS -->
      </div>
    </div>
  </div>

</div>

<script>
  // ---------- Utility Functions ----------
  const $ = (s) => document.querySelector(s);
  const $$ = (s) => document.querySelectorAll(s);
  // Show 0 decimal places (Integer only)
  const fmt = (n) => (Number(n) || 0).toLocaleString("zh-CN", { minimumFractionDigits: 0, maximumFractionDigits: 0 });
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const pad2 = (x) => String(x).padStart(2, "0");

  // ---------- Local persistence + Seeded RNG ----------
  const STORAGE_KEY = "smartPlanner_v1";

  function mulberry32(seed) {
    let t = seed >>> 0;
    return function() {
      t += 0x6D2B79F5;
      let x = t;
      x = Math.imul(x ^ (x >>> 15), x | 1);
      x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }

  function newSeed() {
    // Prefer crypto if available; fallback to time-based
    try {
      if (window.crypto && window.crypto.getRandomValues) {
        const u = new Uint32Array(1);
        window.crypto.getRandomValues(u);
        return u[0] >>> 0;
      }
    } catch (_) {}
    return (Date.now() ^ (Math.random() * 0xFFFFFFFF)) >>> 0;
  }

  // FNV-1a 32-bit hash + stable stringify (ç”¨äºâ€œåŒè¾“å…¥åŒè®¡åˆ’â€)
  function fnv1a32(str) {
    let h = 0x811c9dc5;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 0x01000193);
    }
    return h >>> 0;
  }
  function stableStringify(obj) {
    if (obj === null || typeof obj !== "object") return JSON.stringify(obj);
    if (Array.isArray(obj)) return "[" + obj.map(stableStringify).join(",") + "]";
    const keys = Object.keys(obj).sort();
    return "{" + keys.map(k => JSON.stringify(k) + ":" + stableStringify(obj[k])).join(",") + "}";
  }

  function loadPersisted() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (_) {
      return null;
    }
  }

  function savePersisted(data) {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    } catch (_) {}
  }

  function clearPersisted() {
    try { localStorage.removeItem(STORAGE_KEY); } catch (_) {}
  }

  // Debounce for smooth inputs
  function debounce(func, wait) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  // Date helpers
  function daysInMonth(y, m1) { return new Date(y, m1, 0).getDate(); }
  function makeDate(y, m1, d) { return new Date(y, m1 - 1, clamp(d, 1, daysInMonth(y, m1))); }
  function addDays(dt, n) { const x = new Date(dt); x.setDate(x.getDate() + n); return x; }
  function dateISO(dt) { return `${dt.getFullYear()}-${pad2(dt.getMonth()+1)}-${pad2(dt.getDate())}`; }
  function getDayName(dt) { const days = ['å‘¨æ—¥','å‘¨ä¸€','å‘¨äºŒ','å‘¨ä¸‰','å‘¨å››','å‘¨äº”','å‘¨å…­']; return days[dt.getDay()]; }

  // ---------- Core Logic (Business Logic) ----------

  const HARD_MIN_SWIPE = 10000; // å•ç¬”åˆ·å¡ç¡¬ä¸‹é™ï¼š1ä¸‡å…ƒ
  const sumArr = (arr) => (arr || []).reduce((a, b) => a + (Number(b) || 0), 0);

  /**
   * ç”Ÿæˆâ€œçœ‹èµ·æ¥æ›´åƒçœŸå®æ¶ˆè´¹â€çš„æ•´æ•°æ‹†åˆ†ï¼š
   * - æ€»å’Œä¸¥æ ¼ç­‰äº amountï¼ˆæ•´æ•°ï¼‰
   * - æ¯ç¬”å¿…é¡»åœ¨ [minChunk, maxChunk] å†…ï¼ˆç¡¬çº¦æŸï¼šä¸å¾—ä½äº 1 ä¸‡ï¼‰
   * - é‡‘é¢è¦â€œä¸è§„åˆ™â€ï¼šå°½é‡é¿å…æ•´ç™¾/æ•´åƒï¼ˆå¦‚ 19400 / 29000 / 50000ï¼‰
   * - åå¥½æ¥è¿‘ maxChunkï¼ˆä¾‹å¦‚ 5 ä¸‡ï¼‰ï¼Œä»¥å‡å°‘ç¬”æ•°ä¸æ—¥æœŸ
   * - å¸¦æœ‰å…œåº•é€»è¾‘ï¼Œé¿å…æç«¯å‚æ•°å¯¼è‡´é¡µé¢å¼‚å¸¸
   */
  function splitIntoChunks(amount, minChunk, maxChunk, rng) {
    amount = Math.round(Number(amount) || 0);
    minChunk = Math.max(HARD_MIN_SWIPE, Math.round(Number(minChunk)));
    maxChunk = Math.max(minChunk, Math.round(Number(maxChunk)));
    rng = rng || Math.random;

    if (amount <= 0) return [];
    if (amount < minChunk) return []; // ä¸å…è®¸ç”Ÿæˆä½äºå•ç¬”ä¸‹é™çš„åˆ·å¡

    try {
      const isTooRound = (x) => (x % 100 === 0) || (x % 1000 === 0);

      // å¯è¡Œæ€§ï¼šå­˜åœ¨ n ä½¿å¾— n*minChunk <= amount <= n*maxChunk
      const minN = Math.ceil(amount / maxChunk);
      const maxN = Math.floor(amount / minChunk);
      if (minN > maxN) return [];

      // é»˜è®¤æœ€å°‘ç¬”æ•°ï¼›è‹¥å•ç¬”é‡‘é¢è¿‡æ•´ä¸”å¯æ‹† 2 ç¬”ï¼Œåˆ™æ‹† 2 ç¬”è®©å®ƒæ›´åƒçœŸå®æ¶ˆè´¹
      let n = minN;
      if (n === 1 && isTooRound(amount) && maxN >= 2 && amount >= 2 * minChunk) n = 2;

      // å…ˆç”Ÿæˆ n ç¬”â€œæ¥è¿‘ maxChunk ä½†ä¸ç­‰äº maxChunkâ€çš„ä¸è§„åˆ™é‡‘é¢
      const chunks = [];
      const jitterMax = Math.min(2333, Math.max(0, maxChunk - minChunk)); // æŠ–åŠ¨å¹…åº¦ï¼ˆå¯è°ƒï¼‰
      for (let i = 0; i < n; i++) {
        // base å°½é‡é è¿‘ maxChunkï¼Œä½†é¿å…åˆšå¥½ maxChunk
        let base = maxChunk;
        if (jitterMax > 0) base = maxChunk - (Math.floor(rng() * jitterMax) + 1);
        base = clamp(base, minChunk, maxChunk);
        if (isTooRound(base)) base = clamp(base - 37, minChunk, maxChunk);
        chunks.push(base);
      }

      // è°ƒæ•´æ€»å’Œåˆ°ç²¾ç¡® amountï¼ˆå°æ­¥è°ƒæ•´ï¼Œé¿å…æŠŠæ•°è°ƒæˆæ•´ç™¾ï¼‰
      let delta = amount - sumArr(chunks);
      let guard = 0;
      while (delta !== 0 && guard++ < 20000) {
        const idx = Math.floor(rng() * n);
        const cur = chunks[idx];

        if (delta > 0) {
          const room = maxChunk - cur;
          if (room <= 0) continue;
          const step = Math.min(room, delta, 97); // å°æ­¥åŠ 
          chunks[idx] = cur + step;
          delta -= step;
        } else {
          const room = cur - minChunk;
          if (room <= 0) continue;
          const step = Math.min(room, -delta, 97); // å°æ­¥å‡
          chunks[idx] = cur - step;
          delta += step;
        }
      }
      if (delta !== 0) return [];

      // å»æ•´ç™¾/æ•´åƒï¼šä¸¤ç¬”ä¹‹é—´æŒª 1~99ï¼Œä¸æ”¹å˜æ€»å’Œ
      for (let t = 0; t < 500; t++) {
        const i = chunks.findIndex(isTooRound);
        if (i === -1) break;
        const j = chunks.findIndex((_, k) => k !== i);
        if (j === -1) break;
        const k = Math.floor(rng() * 99) + 1;

        if (chunks[i] + k <= maxChunk && chunks[j] - k >= minChunk) {
          chunks[i] += k; chunks[j] -= k;
        } else if (chunks[i] - k >= minChunk && chunks[j] + k <= maxChunk) {
          chunks[i] -= k; chunks[j] += k;
        }
      }

      // æ ¡éªŒ
      if (chunks.some(x => x < minChunk || x > maxChunk)) return [];
      if (sumArr(chunks) !== amount) return [];

      // æ‰“æ•£é¡ºåº
      for (let i = chunks.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [chunks[i], chunks[j]] = [chunks[j], chunks[i]];
      }
      return chunks;
    } catch (e) {
      console.error("Split error, using fallback", e);
      return [];
    }
  }

  function monthKey(dt) {
    return `${dt.getFullYear()}-${pad2(dt.getMonth() + 1)}`;
  }

  function isTooRoundAmount(x) {
    x = Math.round(Number(x) || 0);
    return (x % 100 === 0) || (x % 1000 === 0);
  }

  /**
   * åœ¨â€œåŒå¡åŒæœˆâ€çš„å¤šç¬”åˆ·å¡ä¹‹é—´æŒªåŠ¨ 1~99ï¼Œå°½é‡æ¶ˆé™¤æ•´ç™¾/æ•´åƒé‡‘é¢ï¼š
   * - ä¸æ”¹å˜æ€»é¢
   * - ä¸è®©ä»»ä½•ä¸€ç¬”è·Œç ´ minChunk æˆ–è¶…è¿‡ maxChunk
   * - è‹¥è¯¥å¡è¯¥æœˆåªæœ‰ 1 ç¬”åˆ·å¡ï¼Œåˆ™æ— æ³•å¤„ç†ï¼ˆä¼šä¿ç•™åŸå€¼ï¼‰
   */
  function smoothRoundAmounts(events, minChunk, maxChunk, rng) {
    rng = rng || Math.random;
    const byGroup = new Map(); // key -> event[]
    for (const e of events) {
      if (!['early', 'late', 'extra'].includes(e.type)) continue;
      const key = `${monthKey(e.date)}|${e.card}`;
      if (!byGroup.has(key)) byGroup.set(key, []);
      byGroup.get(key).push(e);
    }

    for (const [key, evs] of byGroup.entries()) {
      if (evs.length <= 1) continue;

      // å°è¯•å¤šè½®ä¿®å¤
      let guard = 0;
      while (guard++ < 2000) {
        const idx = evs.findIndex(e => isTooRoundAmount(e.amount));
        if (idx === -1) break;

        const a = evs[idx];
        let fixed = false;

        // éšæœºæŒ‘è‹¥å¹²ä¸ªä¼™ä¼´ï¼Œå°è¯• +k/-k
        for (let tries = 0; tries < 60 && !fixed; tries++) {
          const j = Math.floor(rng() * evs.length);
          if (j === idx) continue;
          const b = evs[j];

          const k = Math.floor(rng() * 99) + 1; // 1..99

          // æ–¹æ¡ˆ1ï¼ša + kï¼Œb - k
          if (a.amount + k <= maxChunk && b.amount - k >= minChunk) {
            const na = a.amount + k;
            const nb = b.amount - k;
            if (!isTooRoundAmount(na)) {
              a.amount = na;
              b.amount = nb;
              fixed = true;
              break;
            }
          }

          // æ–¹æ¡ˆ2ï¼ša - kï¼Œb + k
          if (a.amount - k >= minChunk && b.amount + k <= maxChunk) {
            const na = a.amount - k;
            const nb = b.amount + k;
            if (!isTooRoundAmount(na)) {
              a.amount = na;
              b.amount = nb;
              fixed = true;
              break;
            }
          }
        }

        // å¦‚æœè¿™ç¬”å®åœ¨ä¿®ä¸æ‰ï¼ˆæ¯”å¦‚ä¼™ä¼´éƒ½å¡åœ¨è¾¹ç•Œï¼‰ï¼Œå°±è·³å‡ºé¿å…æ­»å¾ªç¯
        if (!fixed) break;
      }
    }

    return events;
  }

  /**
   * æŠŠæ‰€æœ‰â€œåˆ·å¡äº‹ä»¶â€åˆ†é…åˆ°å•†æˆ·æ± ï¼ˆæ¯æœˆæ¯å•†æˆ· capï¼‰ï¼Œè¶…å‡ºåˆ™è‡ªåŠ¨æ‰©å®¹å¹¶ç»™å‡ºæç¤ºã€‚
   */
  function assignMerchantsToEvents(events, merchantCount, merchantCap) {
    const pools = new Map(); // monthKey -> { cap, remain: number[] }
    const overflow = new Map(); // monthKey -> max merchant index used

    function getPool(mk) {
      if (!pools.has(mk)) {
        pools.set(mk, { cap: merchantCap, remain: Array(merchantCount).fill(merchantCap) });
      }
      return pools.get(mk);
    }

    for (const e of events) {
      if (!['early', 'late', 'extra'].includes(e.type)) continue; // è¿˜æ¬¾ä¸åˆ†é…å•†æˆ·
      const mk = monthKey(e.date);
      const pool = getPool(mk);

      // ç¡¬ä¿æŠ¤ï¼šå•ç¬”ä¸èƒ½è¶…è¿‡å•†æˆ· cap
      if (e.amount > merchantCap) {
        e.merchant = `å•†æˆ·?`;
        e.note = `${e.note}ï½œâš  å•ç¬”è¶…è¿‡å•†æˆ·ä¸Šé™`;
        continue;
      }

      let idx = pool.remain.findIndex(r => r >= e.amount);
      if (idx === -1) {
        // æ‰©å®¹ï¼šæ–°å¢å•†æˆ·
        pool.remain.push(merchantCap);
        idx = pool.remain.length - 1;
      }
      pool.remain[idx] -= e.amount;
      e.merchant = `å•†æˆ·${idx + 1}`;
      overflow.set(mk, Math.max(overflow.get(mk) || 0, idx + 1));
    }

    // ç”Ÿæˆæç¤º
    const notes = [];
    for (const [mk, used] of overflow.entries()) {
      if (used > merchantCount) {
        notes.push(`${mk} éœ€è¦ ${used} ä¸ªå•†æˆ·ï¼ˆè¶…è¿‡è®¾ç½®çš„ ${merchantCount} ä¸ªï¼‰`);
      }
    }
    return { events, merchantNotes: notes };
  }

  function computeCardSchedule(card, config) {
    const { y, m, mode, minChunk, maxChunk, rng } = config;
    const { name, limitL, stmtDay, dueDay, monthlyS } = card;

    const dim = daysInMonth(y, m);
    const stmtDate = makeDate(y, m, stmtDay);
    const chargeStart = addDays(stmtDate, 1);
    
    let dueDate = makeDate(y, m, dueDay);
    if (dueDay < stmtDay) {
      const ny = (m === 12) ? y + 1 : y;
      const nm = (m === 12) ? 1 : m + 1;
      dueDate = makeDate(ny, nm, dueDay);
    }

    const events = [];
    const warnings = [];
    const effectiveMinChunk = Math.max(HARD_MIN_SWIPE, Math.round(Number(minChunk)));
    const effectiveMaxChunk = Math.max(effectiveMinChunk, Math.round(Number(maxChunk)));

    // 1. Initial State
    // Steady mode: assume we ended last month full (or at target).
    // Outstanding cannot exceed Limit.
    const startOutstanding = (mode === "steady") ? Math.min(monthlyS, limitL) : 0;
    
    // We need to track the 'real-time' simulated balance on the card
    let currentOutstanding = startOutstanding;
    let totalCharged = 0;
    const target = monthlyS;

    // --- Phase 1: Charge immediately after statement (using existing free limit) ---
    // Available = Limit - CurrentOutstanding
    let avail1 = Math.max(0, limitL - currentOutstanding);
    let charge1 = Math.min(avail1, target - totalCharged);
    
    // å•ç¬”ä¸‹é™ï¼šå°äºä¸‹é™å°±ä¸ç”Ÿæˆåˆ·å¡ï¼ˆç•™åˆ°åç»­/æˆ–æç¤ºæ— æ³•æ’æœŸï¼‰
    if (charge1 > 0 && charge1 < effectiveMinChunk) charge1 = 0;

    if (charge1 > 0) {
      const chunks = splitIntoChunks(charge1, effectiveMinChunk, effectiveMaxChunk, rng);
      const actual = sumArr(chunks);
      if (actual <= 0) {
        warnings.push(`é¦–åˆ·é˜¶æ®µé‡‘é¢ Â¥${fmt(charge1)} ç”±äºâ€œå•ç¬”â‰¥Â¥${fmt(effectiveMinChunk)}â€æ— æ³•æ‹†åˆ†ï¼Œå·²è·³è¿‡ã€‚`);
        charge1 = 0;
      } else if (actual !== charge1) {
        warnings.push(`é¦–åˆ·é˜¶æ®µåŸè®¡åˆ’ Â¥${fmt(charge1)}ï¼Œå¯æ‰§è¡Œ Â¥${fmt(actual)}ï¼ˆå—å•ç¬”çº¦æŸï¼‰ã€‚`);
        charge1 = actual;
      }
      chunks.forEach((amt, i) => events.push({
        date: chargeStart, 
        type: "early", 
        amount: amt, 
        card: name, 
        note: `è´¦å•æ—¥åé¦–åˆ· ${i+1}/${chunks.length}`
      }));
      totalCharged += charge1;
      currentOutstanding += charge1;
    }

    // --- Phase 2: Repayment Day Operations ---
    
    // Step A: Regular Repayment (Bill from last month)
    // In steady mode, the bill is 'startOutstanding'. In oneoff, it's 0.
    const billToRepay = startOutstanding;
    
    if (billToRepay > 0) {
      events.push({
        date: dueDate,
        type: "repay-std", // Standard repayment
        amount: billToRepay,
        card: name,
        note: "å½’è¿˜ä¸ŠæœŸè´¦å•"
      });
      currentOutstanding -= billToRepay;
    }

    // Step B: Charge again using the space freed up by repayment
    // Available = Limit - CurrentOutstanding (which is now lower)
    let avail2 = Math.max(0, limitL - currentOutstanding);
    let charge2 = Math.min(avail2, target - totalCharged);

    if (charge2 > 0 && charge2 < effectiveMinChunk) charge2 = 0;

    if (charge2 > 0) {
      const chunks = splitIntoChunks(charge2, effectiveMinChunk, effectiveMaxChunk, rng);
      const actual = sumArr(chunks);
      if (actual <= 0) {
        warnings.push(`è¡¥åˆ·é˜¶æ®µé‡‘é¢ Â¥${fmt(charge2)} ç”±äºâ€œå•ç¬”â‰¥Â¥${fmt(effectiveMinChunk)}â€æ— æ³•æ‹†åˆ†ï¼Œå·²è·³è¿‡ã€‚`);
        charge2 = 0;
      } else if (actual !== charge2) {
        warnings.push(`è¡¥åˆ·é˜¶æ®µåŸè®¡åˆ’ Â¥${fmt(charge2)}ï¼Œå¯æ‰§è¡Œ Â¥${fmt(actual)}ï¼ˆå—å•ç¬”çº¦æŸï¼‰ã€‚`);
        charge2 = actual;
      }
      chunks.forEach((amt, i) => events.push({
        date: dueDate,
        type: "late",
        amount: amt,
        card: name,
        note: `è¿˜æ¬¾æ—¥åè¡¥åˆ· ${i+1}/${chunks.length}`
      }));
      totalCharged += charge2;
      currentOutstanding += charge2;
    }

    // --- Phase 3: Extra Cycling (ç›®æ ‡ > é¢åº¦ æ—¶çš„å¾ªç¯ï¼šè¿˜ -> åˆ· -> è¿˜ -> åˆ· ...) ---
    let remaining = target - totalCharged;
    let extraCharged = 0;
    let cycleGuard = 0;

    // è¯´æ˜ï¼šæˆ‘ä»¬æŠŠæ‰€æœ‰å¾ªç¯æ“ä½œéƒ½å®‰æ’åœ¨ dueDateï¼ˆä¾¿äºæ‰§è¡Œï¼‰ï¼›è‹¥ä½ å¸Œæœ›åˆ†æ•£åˆ°å¤šå¤©ï¼Œå¯å†å‡çº§ã€‚
    while (remaining > 0 && cycleGuard++ < 50) {
      const available = Math.max(0, limitL - currentOutstanding);
      if (available > 0) {
        const charge = Math.min(available, remaining);
        if (charge < effectiveMinChunk) {
          warnings.push(`å‰©ä½™ Â¥${fmt(remaining)} ä¸­æœ‰ Â¥${fmt(charge)} å°äºå•ç¬”ä¸‹é™ Â¥${fmt(effectiveMinChunk)}ï¼Œæ— æ³•ç»§ç»­å¾ªç¯åˆ·ã€‚`);
          break;
        }
        const chunks = splitIntoChunks(charge, effectiveMinChunk, effectiveMaxChunk, rng);
        const actual = sumArr(chunks);
        if (actual <= 0) {
          warnings.push(`å¾ªç¯åˆ·é‡‘é¢ Â¥${fmt(charge)} ç”±äºå•ç¬”çº¦æŸæ— æ³•æ‹†åˆ†ï¼Œå·²åœæ­¢ã€‚`);
          break;
        }
        chunks.forEach((amt, i) => events.push({
          date: dueDate,
          type: "extra",
          amount: amt,
          card: name,
          note: `å¾ªç¯åˆ· ${i+1}/${chunks.length}`
        }));
        remaining -= actual;
        extraCharged += actual;
        totalCharged += actual;
        currentOutstanding += actual;
        continue;
      }

      // available == 0ï¼šéœ€è¦è¿˜æ¬¾é‡Šæ”¾é¢åº¦ã€‚ä¸ºç®€å•ä¸”ä¸ä¼šå‡ºè´Ÿæ•°ï¼Œè¿™é‡Œé€‰æ‹©â€œè¿˜æ¸…å½“å‰æ¬ æ¬¾â€å†ç»§ç»­åˆ·ã€‚
      const repayAmt = currentOutstanding;
      if (repayAmt <= 0) break;
      events.push({
        date: dueDate,
        type: "repay-extra",
        amount: repayAmt,
        card: name,
        note: "å¾ªç¯è¿˜æ¬¾ (æ¸…ç©ºæ¬ æ¬¾è…¾é¢åº¦)"
      });
      currentOutstanding -= repayAmt; // -> 0
    }

    // Investment potential: Weighted average or simplified peak?
    // Simplified: The max balance we held "for a while".
    // Phase 1 + Previous is held until Due Date.
    const investPeak = (mode === "steady") ? (startOutstanding + charge1) : charge1;

    return {
      name, limitL, monthlyS,
      stmtDate, dueDate, chargeStart,
      phase1: charge1, 
      phase2: charge2 + extraCharged, // dueDate å½“å¤©çš„åˆ·å¡æ€»é¢ï¼ˆè¡¥åˆ· + å¾ªç¯åˆ·ï¼‰
      investPeak, 
      events,
      warnings: remaining > 0
        ? [...warnings, `ä»æœ‰ Â¥${fmt(remaining)} æœªæ’æœŸï¼ˆè¯·æ£€æŸ¥é¢åº¦ / å•ç¬”ä¸‹é™â‰¥Â¥${fmt(effectiveMinChunk)} / å•ç¬”ä¸Šé™ï¼‰ã€‚`]
        : warnings
    };
  }

  // ---------- UI Logic ----------

  const state = {
    cards: [
      { name: "ä¸­ä¿¡ç™½", limitL: 129000, stmtDay: 2, dueDay: 21, monthlyS: 100000 },
      { name: "å¹¿å‘ç™½", limitL: 69400, stmtDay: 3, dueDay: 23, monthlyS: 50000 },
      { name: "å†œè¡Œç™½", limitL: 25000, stmtDay: 5, dueDay: 16, monthlyS: 40000 }
    ],
    // è®¡åˆ’â€œç›å€¼â€ï¼šé»˜è®¤ 0 è¡¨ç¤ºåŒè¾“å…¥åŒç»“æœï¼›ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆâ€æ‰ä¼šæ”¹å˜
    planSalt: 0,
    doneIds: {} // { [eventId]: true }
  };

  function init() {
    // Load from localStorage if exists
    const persisted = loadPersisted();
    if (persisted && typeof persisted === 'object') {
      if (Array.isArray(persisted.cards) && persisted.cards.length) state.cards = persisted.cards;
      if (typeof persisted.planSalt === 'number') state.planSalt = persisted.planSalt >>> 0;
      if (persisted.doneIds && typeof persisted.doneIds === 'object') state.doneIds = persisted.doneIds || {};
    }

    // Set default month
    const now = new Date();
    const defaultMonth = `${now.getFullYear()}-${pad2(now.getMonth()+1)}`;
    $('#planMonth').value = (persisted && persisted.planMonth) ? persisted.planMonth : defaultMonth;
    $('#minChunk').value = (persisted && persisted.minChunk) ? String(persisted.minChunk) : $('#minChunk').value;
    $('#maxChunk').value = (persisted && persisted.maxChunk) ? String(persisted.maxChunk) : $('#maxChunk').value;
    $('#merchantCount').value = (persisted && persisted.merchantCount) ? String(persisted.merchantCount) : $('#merchantCount').value;
    $('#merchantCap').value = (persisted && persisted.merchantCap) ? String(persisted.merchantCap) : $('#merchantCap').value;
    $('#mode').value = (persisted && persisted.mode) ? String(persisted.mode) : $('#mode').value;
    
    // Global Listeners
    ['planMonth', 'minChunk', 'maxChunk', 'merchantCount', 'merchantCap', 'mode'].forEach(id => {
      document.getElementById(id).addEventListener('input', runCalculation);
    });

    // Timeline: toggle done
    $('#timeline').addEventListener('click', (ev) => {
      const btn = ev.target.closest('[data-eid]');
      if (!btn) return;
      const id = btn.getAttribute('data-eid');
      if (!id) return;
      if (state.doneIds && state.doneIds[id]) delete state.doneIds[id];
      else state.doneIds[id] = true;

      // persist immediately
      savePersisted({
        planMonth: $('#planMonth').value,
        minChunk: Number($('#minChunk').value),
        maxChunk: Number($('#maxChunk').value),
        merchantCount: Number($('#merchantCount').value),
        merchantCap: Number($('#merchantCap').value),
        mode: $('#mode').value,
        cards: state.cards,
        planSalt: state.planSalt >>> 0,
        doneIds: state.doneIds
      });

      // redraw without changing plan
      if (window.__lastResults && window.__lastEvents) {
        updateGlobalStats(window.__lastResults, window.__lastEvents);
        renderTimeline(window.__lastEvents);
      } else {
        runCalculation();
      }
    });

    // Seed controls
    $('#regenPlan').addEventListener('click', () => {
      state.planSalt = newSeed();
      // ç«‹å³ä¿å­˜ï¼Œé¿å…åˆ·æ–°å¯¼è‡´ä¸¢å¤±
      savePersisted({
        planMonth: $('#planMonth').value,
        minChunk: Number($('#minChunk').value),
        maxChunk: Number($('#maxChunk').value),
        merchantCount: Number($('#merchantCount').value),
        merchantCap: Number($('#merchantCap').value),
        mode: $('#mode').value,
        cards: state.cards,
        planSalt: state.planSalt >>> 0
      });
      runCalculation();
    });
    $('#resetLocal').addEventListener('click', () => {
      clearPersisted();
      // reload to default
      location.reload();
    });

    // Add Card Listener
    $('#addCard').addEventListener('click', () => {
      state.cards.push({ name: "æ–°å¡ç‰‡", limitL: 50000, stmtDay: 1, dueDay: 20, monthlyS: 30000 });
      renderTable();
      runCalculation();
    });

    renderTable();
    runCalculation();
  }

  const persistNow = debounce(() => {
    savePersisted({
      planMonth: $('#planMonth').value,
      minChunk: Number($('#minChunk').value),
      maxChunk: Number($('#maxChunk').value),
      merchantCount: Number($('#merchantCount').value),
      merchantCap: Number($('#merchantCap').value),
      mode: $('#mode').value,
      cards: state.cards,
      planSalt: state.planSalt >>> 0,
      doneIds: state.doneIds
    });
  }, 150);

  function renderTable() {
    const tbody = $('#cardsTbody');
    tbody.innerHTML = '';
    
    state.cards.forEach((card, idx) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><input class="table-input" data-idx="${idx}" data-field="name" value="${card.name}" /></td>
        <td><input type="number" class="table-input" data-idx="${idx}" data-field="limitL" value="${card.limitL}" /></td>
        <td><input type="number" class="table-input" data-idx="${idx}" data-field="stmtDay" value="${card.stmtDay}" min="1" max="31" /></td>
        <td><input type="number" class="table-input" data-idx="${idx}" data-field="dueDay" value="${card.dueDay}" min="1" max="31" /></td>
        <td><input type="number" class="table-input" data-idx="${idx}" data-field="monthlyS" value="${card.monthlyS}" /></td>
        <td class="text-right">
          <button class="btn btn-danger-ghost" onclick="removeCard(${idx})">
            <svg viewBox="0 0 24 24" class="icon"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
          </button>
        </td>
      `;
      tbody.appendChild(tr);
    });

    // Bind inputs
    $$('.table-input').forEach(inp => {
      inp.addEventListener('input', (e) => {
        const idx = e.target.dataset.idx;
        const field = e.target.dataset.field;
        state.cards[idx][field] = e.target.type === 'number' ? Number(e.target.value) : e.target.value;
        persistNow();
        debouncedCalc(); // Auto refresh
      });
    });
  }

  window.removeCard = (idx) => {
    state.cards.splice(idx, 1);
    persistNow();
    renderTable();
    runCalculation();
  };

  const debouncedCalc = debounce(runCalculation, 300);

  function runCalculation() {
    const pm = $('#planMonth').value.split('-');
    // å•ç¬”ç¡¬ä¸‹é™ï¼š1ä¸‡å…ƒ
    const rawMin = Number($('#minChunk').value);
    const rawMax = Number($('#maxChunk').value);
    const rawMerchantCount = Number($('#merchantCount').value);
    const rawMerchantCap = Number($('#merchantCap').value);

    const normalizedMin = Math.max(HARD_MIN_SWIPE, Math.round(rawMin || HARD_MIN_SWIPE));
    const normalizedMax = Math.max(normalizedMin, Math.round(rawMax || normalizedMin));
    const merchantCount = Math.max(1, Math.round(rawMerchantCount || 5));
    const merchantCap = Math.max(normalizedMin, Math.round(rawMerchantCap || 50000));

    // åŒæ­¥å›å¡«ï¼Œé¿å… UI å’Œå®é™…è®¡ç®—ä¸ä¸€è‡´
    if (Number($('#minChunk').value) !== normalizedMin) $('#minChunk').value = String(normalizedMin);
    if (Number($('#maxChunk').value) !== normalizedMax) $('#maxChunk').value = String(normalizedMax);
    if (Number($('#merchantCount').value) !== merchantCount) $('#merchantCount').value = String(merchantCount);
    if (Number($('#merchantCap').value) !== merchantCap) $('#merchantCap').value = String(merchantCap);

    const config = {
      y: Number(pm[0]),
      m: Number(pm[1]),
      // å•ç¬”ä¸Šé™è¿˜è¦å—â€œå•†æˆ·å•æœˆä¸Šé™â€å½±å“ï¼ˆæ¯å•†æˆ· 5 ä¸‡ï¼‰
      minChunk: normalizedMin,
      maxChunk: Math.min(normalizedMax, merchantCap),
      merchantCount,
      merchantCap,
      mode: $('#mode').value
    };

    // åŒè¾“å…¥åŒè®¡åˆ’ï¼šç”¨â€œé…ç½®ç­¾åâ€åšç§å­ï¼›planSalt åªæœ‰ç‚¹å‡»â€œé‡æ–°ç”Ÿæˆâ€æ‰ä¼šæ”¹å˜
    const signature = stableStringify({
      planMonth: $('#planMonth').value,
      minChunk: config.minChunk,
      maxChunk: config.maxChunk,
      merchantCount: config.merchantCount,
      merchantCap: config.merchantCap,
      mode: config.mode,
      cards: state.cards
    });
    const seed = (fnv1a32(signature) ^ (state.planSalt >>> 0)) >>> 0;
    config.rng = mulberry32(seed);

    // ç«‹å³ä¿å­˜ï¼ˆä¸è¦ debounceï¼‰ï¼Œä¿è¯åˆ·æ–°ä¹Ÿä¸å˜
    savePersisted({
      planMonth: $('#planMonth').value,
      minChunk: Number($('#minChunk').value),
      maxChunk: Number($('#maxChunk').value),
      merchantCount: Number($('#merchantCount').value),
      merchantCap: Number($('#merchantCap').value),
      mode: $('#mode').value,
      cards: state.cards,
      planSalt: state.planSalt >>> 0,
      doneIds: state.doneIds
    });

    const results = state.cards.map(c => computeCardSchedule(c, config));
    const allEvents = results.flatMap(r => r.events).sort((a,b) => a.date - b.date);

    // åœ¨åŒå¡åŒæœˆèŒƒå›´å†…â€œå›æ‹¨æ‰“æ•£â€æ•´ç™¾/æ•´åƒé‡‘é¢ï¼ˆä¸æ”¹å˜æ€»é¢ã€ä¸”ä¸ç ´å•ç¬”èŒƒå›´ï¼‰
    smoothRoundAmounts(allEvents, config.minChunk, config.maxChunk, config.rng);

    // åˆ†é…å•†æˆ·ï¼ˆè·¨å¡å…±äº«åŒä¸€å¥—å•†æˆ·æ± ï¼Œç¬¦åˆâ€œ5ä¸ªå•†æˆ·æ¯æœˆå„5ä¸‡â€çš„å‡è®¾ï¼‰
    const { events: enrichedEvents, merchantNotes } = assignMerchantsToEvents(allEvents, config.merchantCount, config.merchantCap);
    // å°†â€œéœ€è¦æ›´å¤šå•†æˆ·â€çš„æç¤ºå†™åˆ°å…¨å±€ç»Ÿè®¡åŒº
    window.__merchantNotes = merchantNotes;

    // ç»™äº‹ä»¶ç”Ÿæˆç¨³å®š idï¼Œå¹¶ç¼“å­˜ä¾›â€œå·²æ“ä½œâ€ä½¿ç”¨
    for (const e of enrichedEvents) {
      e.id = `${dateISO(e.date)}|${e.card}|${e.type}|${e.amount}|${e.note || ''}|${e.merchant || ''}`;
    }
    window.__lastResults = results;
    window.__lastEvents = enrichedEvents;
    
    // Update UI
    updateGlobalStats(results, enrichedEvents);
    renderTimeline(enrichedEvents);
    renderSummary(results);
  }

  function updateGlobalStats(results, events) {
    const totalInvestPeak = results.reduce((a,b) => a + b.investPeak, 0);
    const totalFlow = events.reduce((a,b) => a + b.amount, 0);
    const planMonthStr = $('#planMonth').value; // YYYY-MM
    const remainingSum = events.reduce((acc, e) => {
      if (!e || !e.date) return acc;
      // åªç»Ÿè®¡å½“æœˆäº‹ä»¶ï¼ˆæŒ‰äº‹ä»¶æ—¥æœŸæ‰€å±æœˆä»½ï¼‰
      const mk = `${e.date.getFullYear()}-${pad2(e.date.getMonth()+1)}`;
      if (mk !== planMonthStr) return acc;
      if (state.doneIds && state.doneIds[e.id]) return acc;
      // è¿˜æ¬¾æ˜¯è´Ÿå‘ï¼Œä½†è¿™é‡Œæ˜¾ç¤ºâ€œéœ€æ“ä½œèµ„é‡‘é‡â€ç”¨ç»å¯¹å€¼
      return acc + Math.abs(Number(e.amount) || 0);
    }, 0);
    
    $('#globalStat').innerHTML = `
      <div style="font-size:12px; color:var(--text-sec);">ç†è®ºæœ€å¤§èµ„é‡‘å ç”¨</div>
      <div style="font-size:24px; font-weight:700; color:var(--primary);">Â¥ ${fmt(totalInvestPeak)}</div>
      ${Array.isArray(window.__merchantNotes) && window.__merchantNotes.length
        ? `<div class="pill warning" style="margin-top:6px; display:inline-flex;">âš  ${window.__merchantNotes.join('ï¼›')}</div>`
        : ``}
    `;
    $('#eventCount').innerText = `${events.length} ç¬”è§„åˆ’`;
    const remainEl = document.getElementById('remainSum');
    if (remainEl) remainEl.innerText = `å‰©ä½™ Â¥${fmt(remainingSum)}`;
  }

  function renderTimeline(events) {
    const container = $('#timeline');
    if (events.length === 0) {
      container.innerHTML = '<div class="muted" style="padding:20px; text-align:center;">æš‚æ— è§„åˆ’æ•°æ®ï¼Œè¯·å…ˆé…ç½®å¡ç‰‡ã€‚</div>';
      return;
    }

    // Sort: Date -> Order of Type (Repay first, then Charge)
    const typeOrder = { "repay-std": 1, "repay-extra": 2, "early": 3, "late": 4, "extra": 5 };
    events.sort((a,b) => {
      const d = a.date - b.date;
      if (d !== 0) return d;
      return (typeOrder[a.type] || 99) - (typeOrder[b.type] || 99);
    });

    let lastDate = '';
    const html = events.map(e => {
      const dStr = dateISO(e.date);
      const isNewDay = dStr !== lastDate;
      lastDate = dStr;
      
      const isRepay = e.type.includes('repay');
      const isDone = !!(state.doneIds && e.id && state.doneIds[e.id]);
      
      // Styling based on type
      let typeLabel = "æœªçŸ¥";
      let pillClass = "blue";
      let amtColor = "var(--text-main)";
      let prefix = "";

      if (e.type === 'early') { typeLabel = "é¦–åˆ·"; pillClass = "green"; prefix = "+"; }
      else if (e.type === 'late') { typeLabel = "è¡¥åˆ·"; pillClass = "green"; prefix = "+"; }
      else if (e.type === 'extra') { typeLabel = "å¾ªç¯åˆ·"; pillClass = "warning"; prefix = "+"; }
      else if (e.type === 'repay-std') { typeLabel = "è´¦å•è¿˜æ¬¾"; pillClass = "purple"; prefix = "-"; amtColor = "#7c3aed"; }
      else if (e.type === 'repay-extra') { typeLabel = "å¾ªç¯è¿˜æ¬¾"; pillClass = "purple"; prefix = "-"; amtColor = "#7c3aed"; }
      
      return `
        <div class="timeline-item ${isDone ? 'done' : ''}">
          <div class="t-date" style="opacity:${isNewDay ? 1 : 0};">
            <span class="t-day">${e.date.getDate()}</span>
            <span class="t-month">${e.date.getMonth()+1}æœˆ</span>
          </div>
          <div class="t-content">
            <div class="t-header">
              <span class="t-card-name" style="${isRepay ? 'color:#6b7280' : ''}">${e.card}</span>
              <span class="t-amount" style="color:${amtColor}">${prefix} ${fmt(e.amount)}</span>
            </div>
            <div class="t-meta">
              <span class="pill ${pillClass}" style="padding:0 6px; font-size:11px; background:${pillClass==='purple'?'#f3e8ff':''}; color:${pillClass==='purple'?'#7c3aed':''};">${typeLabel}</span>
              <span>${getDayName(e.date)}</span>
              ${e.merchant ? `<span class="pill blue" style="padding:0 6px; font-size:11px;">${e.merchant}</span>` : ``}
              ${e.id ? `<span class="pill blue done-toggle" data-eid="${e.id}" style="padding:0 6px; font-size:11px;">${isDone ? 'å·²æ“ä½œ' : 'å·²æ“ä½œ'}</span>` : ``}
              <span>${e.note}</span>
            </div>
          </div>
        </div>
      `;
    }).join('');
    container.innerHTML = html;
  }

  function renderSummary(results) {
    const container = $('#summary');
    container.innerHTML = results.map(r => `
      <div style="border:1px solid var(--border); border-radius:8px; padding:16px;">
        <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
          <strong style="font-size:15px;">${r.name}</strong>
          <span style="color:var(--primary); font-weight:600;">å ç”¨ Â¥${fmt(r.investPeak)}</span>
        </div>
        <div class="grid-2" style="gap:12px; font-size:13px; color:var(--text-sec);">
          <div>
            <div>è´¦å•æ—¥ï¼š${dateISO(r.stmtDate)}</div>
            <div>å»ºè®®åˆ·ï¼š${dateISO(r.chargeStart)} (Â¥${fmt(r.phase1)})</div>
          </div>
          <div>
            <div>è¿˜æ¬¾æ—¥ï¼š${dateISO(r.dueDate)}</div>
            <div>è¡¥åˆ·æ—¥ï¼š${dateISO(r.dueDate)} (Â¥${fmt(r.phase2)})</div>
          </div>
        </div>
        ${r.warnings.length ? `<div class="pill red" style="margin-top:8px;">âš ï¸ ${r.warnings.join(', ')}</div>` : ''}
      </div>
    `).join('');
  }

  // Start
  init();

</script>
</body>
</html>
